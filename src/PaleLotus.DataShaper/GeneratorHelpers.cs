using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace PaleLotus.DataShaper;

internal static class GeneratorHelpers
{
    internal const string ProjectNameSpace = "PaleLotus.DataShaper";
    internal const string GeneratedNote = $"""
                                         //------------------------------------------------------------------------------
                                         // <auto-generated>
                                         //     This code was generated by the {ProjectNameSpace} source generator
                                         //
                                         //     Changes to this file may cause incorrect behavior and will be lost if
                                         //     the code is regenerated.
                                         // </auto-generated>
                                         //------------------------------------------------------------------------------
                                         """;
    
    internal static string GetTypeKind(this INamedTypeSymbol symbol)
    {
        //this must be on top
        if (symbol.IsRecord)
            return "record";
        
        if (symbol.TypeKind == TypeKind.Class)
            return "class";

        return symbol.TypeKind == TypeKind.Struct ? "struct" : "unknown";
    }
      
    internal static string GetAccessModifier(this INamedTypeSymbol symbol) =>
        symbol.DeclaredAccessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Private => "private",
            Accessibility.Protected => "protected",
            Accessibility.ProtectedOrInternal => "protected internal",
            Accessibility.ProtectedAndInternal => "private protected",
            _ => "unknown" // Handle other cases if needed
        };

    internal static string GetNamespace(this BaseTypeDeclarationSyntax syntax)
    {
        var nameSpace = string.Empty;
        
        var potentialNamespaceParent = syntax.Parent;
        
        while (potentialNamespaceParent is not null &&
               potentialNamespaceParent is not NamespaceDeclarationSyntax
               && potentialNamespaceParent is not FileScopedNamespaceDeclarationSyntax)
        {
            potentialNamespaceParent = potentialNamespaceParent.Parent;
        }

        if (potentialNamespaceParent is not BaseNamespaceDeclarationSyntax namespaceParent)
            return nameSpace;

        nameSpace = namespaceParent.Name.ToString();
        
        while (true)
        {
            if (namespaceParent.Parent is not NamespaceDeclarationSyntax parent)
                break;
            nameSpace = $"{namespaceParent.Name}.{nameSpace}";
            namespaceParent = parent;
        }

        return nameSpace;
    }

    public static List<(string Name, string Type)> GetMembersNameAndType(INamedTypeSymbol type, bool nested = true, string prefix = "")
    {
        var members = new List<(string Name, string Type)>();

        foreach (var member in type.GetMembers())
        {
            if (member is not IPropertySymbol { DeclaredAccessibility: Accessibility.Public } &&
                member is not IFieldSymbol { DeclaredAccessibility: Accessibility.Public })
                continue;
            
            var memberName = string.IsNullOrEmpty(prefix) ? member.Name : $"{prefix}.{member.Name}";
            var memberType = member is IPropertySymbol prop ? prop.Type : ((IFieldSymbol)member).Type;
            
            members.Add((memberName, memberType.ToDisplayString()));

            if (nested && IsComplexType(memberType))
                members.AddRange(GetMembersNameAndType((INamedTypeSymbol)memberType, nested, memberName));
        }

        return members;
    }

    public static bool IsComplexType(this ITypeSymbol type) => type is { TypeKind: TypeKind.Class, SpecialType: SpecialType.None };
}